#### 运用多态取代与价格相关的条件逻辑
> 最好不要在另一个对象的属性基础上运用`switch`语句。如果不得不使用，也应该在对象自己的数据上使用，而不是别人的
> 数据上使用。

这意味着`getCharge()`应该移到`Movie`类里去
```java
double getCharge(int dayRented) {
    double result = 0;
    switch (getPriceCode()) {
        case Movie.REGULAR:
            result += 2;
            if (dayRented > 2) {
                result += (dayRented - 2) * 1.5;
            }
            break;
        case Movie.NEW_RELEASE:
            result += dayRented * 3;
            break;
        case Movie.CHILDREN:
            result += 1.5;
            if (dayRented > 1) {
                result += (dayRented - 3) * 1.5;
            }
            break;
        default:
            throw new IllegalArgumentException("illegal price code");
    }
    return result;
}


public double getCharge() {
    return movie.getCharge(dayRented);
}
```
为什么选择将租期长度传给`Movie`对象，而不是将影片类型传给`Rental`对象呢？  
因为本系统可能发生变化的是加入新影片类型，这种变化带有不稳定倾向。如果影片类型有所变化，我希望尽量控制它造成的影响，
所以选择在`Movie`对象内计算费用

#### 使用继承
我们有数种影片类型，他们以不同的方式回答相同的问题。这听起来很像子类的工作。我们可以建立`Movie`的三个子类
`RegularMovie ChildrenMovie NewReleaseMovie` 每个都有自己的计费法，这么一来我们就可以用多态来取代`switch`
语句了。很遗憾这里有个小问题，不能这样干。一步影片可以再生命周期内修改自己的分类，一个对象却不能在生命周期内
修改自己所属的类。不过还有个方法：`State`模式
> 一个对象实例化时已经确定该对象属于哪个类的实例，不能随意更改

引入`State`模式，使用三个重构方法：

- 运用`Replace Type Code with State/Strategy` 将与类型相关的行为搬移至`State`模式内
- 运用`Move Method` 将`switch`语句移到`Price`类
- 最后运用`Replace Conditional with Polymorphism`去掉`switch`语句

